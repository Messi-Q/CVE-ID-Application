# Cross_function_reentrancy

## Vendor
Cross-function Reentrancy

## Vulnerability Type
Cross Function Reentrancy Bug

## Abstract
We found a complex but common cross-function attack scenario in Ethereum smart contracts, where an attacker can undesirably re-enter a function to steal money. The attack scenario can be abstracted as: (1) given a contract `Vulnerable` containing two transfer functions `withdrawPortion` and `withdrawAll`, which can transfer Ether (the cryptocurrency of Ethreum) to another contract. (2) Once the function `withdrawAll` of contract `Vulnerable` is called to withdraw Ether to a contract `Attacker`, the `fallback` function of `Attacker` is automatically invoked. (3) In the `fallback` function, contract `Attacker` calls function `withdrawPortion`, which will undesirably transfer money to `Attacker` again. While reentrancy exploiting one single function has been well studied, the cross-function reentrancy has not yet been issued.

## Details
We present a typical example of cross-function reentrancy in the figure below.

<div align=center><img width="520" height="240" src="./images/cross-function.png"/></div>
<div align=center>Figure 1 An example of cross-function reentrancy</div>

Contract `Vulnerable` contains two transfer functions `withdrawAll` and `withdrawPortion`, both of the two functions can send Ether to another contract address.
* `withdrawAll` declares a transfer operation, which allows a recipient to withdraw all his/her asset.
* `withdrawPortion` declares another transfer operation, which allows a recipient to withdraw part of his/her asset.
```
contract Vulnerable{
  ...
  
  // withdraw all the money
  function withdrawAll(address to) external {
      uint256 amount = userBalances[msg.sender];
      if (userBalances[msg.sender] > 0) {
        require(msg.sender.call.value(amount)());
    	  userBalances[msg.sender] = 0;
      }
  }
  
  // withdraw part of the money
  function withdrawPortion(uint _amount) external {   
     if (userBalances[msg.sender] >= amount) {
        require(msg.sender.call.value(amount)());
        userBalances[msg.sender] -= amount;
     }
  }
}
```

Contract `Attacker` contains an `attack` function and a `fallback` function.
* `attack` initiates the attack to withdraw money by calling the function `withdrawAll`.
* `fallback` calls the function `withdrawPortion` to steal money from contract `Vulnerable`.
```
contract Attacker{
  ...
  
  function attack(){
    vul.withdrawAll(_owner);
  }

  function () payable{ // fallback function
     count++;
     if(count < 10){
       vul.withdrawPortion(1 ether);
     }
  }
}
```

The attack process is as follows:

**Step 1** The contract `Attacker` uses the function `attack` to call the function `withdrawAll` of contract `Vulnerable`,  aiming to withdraw his/her asset (Ether). (attack (Attacker) -> withdrawAll (Vulnerable))

**Step 2** The function `withdrawAll` executes the transfer operation `require(msg.sender.call.value(amount)());` (line 6 in Figure 1 left) to send money to contract `Attacker`. This will automatically trigger the `fallback` function of `Attacker`. (withdrawAll (Vulnerable) -> fallback (Attacker))

**Step 3** The `fallback` function of `Attacker` maliciously invokes the function `withdrawPortion` of `Vulnerable` to withdraw Ether for the second time. (fallback (Attacker) -> withdraw (Vulnerable))

**Step 4** Since `userBalances[msg.sender]` is not set to zero yet, the condition `userBalances[msg.sender] >= amount` (line 11 in Figure 1 left) will be satisfied. Thus, the function `withdrawPortion` executes the transfer operation `require(msg.sender.call.value(amount)());` (line 12 in Figure 1 left) to send money to contract `Attacker`. This will automatically trigger the `fallback` function of `Attacker` again. (withdraw (Vulnerable) -> fallback (Attacker))

**Step 5** Similarly, the `fallback` function re-enters the contract `Vulerable` the third time by calling the function `withdrawPortion`, causing recursive calls. In total, function `withdrawPortion` is called 9 times (`if(count < 10)` (line 11 in Figure 1 right)).  Therefore, by exploiting the reentrant call, the `Attacker` can access the contract `Vulnerable` to withdraw more money than expected. (fallback (Attacker) -> withdraw (Vulnerable) -> ...)

**Analysis** `userBalances[msg.sender]` is the critical value as it records the amount of Ether that the call's recipient holds in the contract. After the transfer operation `require(msg.sender.call.value(amount)());` (line 6 in Figure 1 left) of function `withdrawAll` is executed, the `fallback` function of contract `Attacker` will be triggered before the `userBalances[msg.sender]` is updated, thus making the contract `Vulnerable` believe that the attacker still has enough Ether in the contract. Then, the `fallback` function of contract `Attacker` calls the function `withdrawPortion` of `Vulnerable` recurrently until the `count` reaches 10. `if (count < 10) { vul.withdrawPortion(1 Ether); }`. 

For example, an attacker wants to withdraw 10 Ether from contract `Vulnerable` by calling the function `withdrawAll` of contract `Vulnerable`. Then, the attacker utilizes the `fallback` function to call the function `withdrawPortion` of `Vulnerable` 9 times. In total, the attacker may withdraw 90 Ether, which is much more than expected.


## Conclusion
Overall, we would like to highlight that this reentrancy situation is common in many Ethereum smart contracts. Attackers can make use of two transfer functions of the vulnerable contract and the `fallback` mechanism to re-enter the vulnerable contract for stealing money. Since reentrancy can occur across multiple functions and current reentrancy detection tools are single function-based, solutions aiming at detecting cross-function reentrancy is urgently required.

## Reference
https://consensys.github.io/smart-contract-best-practices/known_attacks/

https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21

https://github.com/Messi-Q/Vulnerabilities/blob/master/Reentrancy_cross_function.sol

