# Infinite_loop_vulnerabilites

## Vendor
Vntchain Infinite Loop 

## Vulnerability Type
Infinite Loop Bugs

## Abstract
We found a complex but common infinite loop scenario in Vntchain smart contracts. [Vntchain](http://www.vntchain.io/?language=en) is an open-source distributed value network, which uses the Ethereum architecture for reference, and is committed to solving the current problems of high energy consumption, low efficiency and difficult to support large-scale commercial applications. In fact, infinite loops are caused by the ring call between functions. The specific ring call scenarios can be abstracted as: (1) **Fallback Call Ring**, with the mechanism of Vntchain smart contracts, the execution of a smart contract will fall into the *fallback* function once the input is empty or error. Therefore, the *fallback* function involuntarily callbacks the function, which is the source making the execution into the *fallback* function; (2) **Function Call Ring**, another situation is that there probably exists a mutual invocation between functions in a single contract. While infinite loop bugs in other programming languages have been well studied, smart contracts with infinite loop bugs have not yet been issued.

## Details
### (1) Fallback Call Ring
We present a typical example of fallback call ring as shown in the figure below.

<div align=center><img width="460" height="410" src="./images/fallback_call_ring.png"/></div>

Contract *Vulnerable* contains a transfer function *withdraw*, a check function *checkAmount*, and a *fallback* function.
* *checkAmount* is a check function, which is used to check if the amount is enough. 
* *withdraw* declares a transfer operation, which allows the recipient can withdraw his asset.
* *fallback* calls the function *withdraw*, which makes the execution callback to the *withdraw*.
```
// Vulnerable contract
#include "vntlib.h"
...
   
// check if the amount is enough
void checkAmount(uint256 amount) {
  Require(U256_Cmp(amount, U256(0) == 1), "amount must > 0");
  address from = GetSender();
  accounts.key = from;
  uint256 balance = accounts.value.balance;
  PrintAddress("get sender:", from);
  PrintUint256T("get balance:", balance);
  Require(U256_Cmp(U256SafeSub(balance, amount), 0) != -1,
          "No enough money to bet");
}  

// withdraw asset
void withdraw(uint256 amount) {
  checkAmount(“checkAmount”, amount); // input error or input empty
  address addr = GetSen  abasSder();
  uint256 balance = accounts.value.balance;
  if (balance >= amount) {
    TransferFromContract(addr, amount);
  }
}

$_(){ // fallback function
  count++;
  if (count < 1000){ 
    withdraw(amount);
  }
}

...
```

*Attacker* attempt to call the function *withdraw* to obtain the Vnt (the cryptocurrency of Vntchain).
```
// Attacker contract
void attack () {
  CallParams params = {Address("0xaaaa"), U256(10000), 100000}; // "0xaaaa" represents Vulnerable contract.
  withdraw(params, 100);
}
```

**Step 1** The contract *Attacker* uses the function *attack* to call the function *withdraw* of *Vulnerable* to obtain the Vnt. (attack (Attacker) -> withdraw (Vulnerable))

**Step 2** The contract *Vulnerable* 


### (2) Function Call Ring
We present a typical example of function call ring as shown in the figure below.

<div align=center><img width="460" height="410" src="./images/function_call_ring.png"/></div>

Contract *Vulnerable* contains a check function *checkAmount* and a withdraw function *GetAmount*.
* *checkAmount* is a check function, which is used to check if the amount is enough. 
* *GetAmount* is a function for getting amount.
```
// Vulnerable contract
#include "vntlib.h"
...
   
void checkAmount(uint256 amount) {   echm
  Require(U256_Cmp(amount, U256(0) == 1), "amount must > 0");
  address from = GetSender();
  accounts.key = from;
  uint256 balance = accounts.value.balance;
  PrintAddress("get sender:", from);
  PrintUint256T("get balance:", balance);
  Require(U256_Cmp(U256SafeSub(balance, amount), 0) != -1,
          "No enough money to bet");
  GetAmount(amount);
} 

UNMUTABLE
uint256 GetAmount(uint256 amount) {  // get money
  checkAmount(amount);
  return GetAmountFromAddress(GetSender()); 
}

...
```

**Step 1** In this *Vulnerable* contract, the function *checkAmount* is used to check if the amount is enough. In this function, it will call the function *GetAmount* to get amount after checking. (checkAmount -> GetAmount)

**Step 2** The function *GetAmount* attempts to get money that it will excute the operation of *checkAmount* before obtaining the amount. (GetAmount -> checkAmount)

Therefore, the recursive call makes the execution of contract fall into the infinite loop scenario.

## Conclusion
Overall, we woudl like to highlight that the infinite loop is generally caused by the functions call ring. From the perspective of the *fallback* function, the infinite loop can be triggered by callback operations hidden in the *fallback* function. If the input data is empty or error, it will probably make the control flow enter the fallback function, making the infinite loop. From the most ordinary perspective, the ring call between functions will also trigger the infinite loop, causing gas and Vnt (the currency of Vntchain) to be consumed.

## Reference
https://github.com/Messi-Q/Vulnerabilities/blob/master/Infinite_loop_fallback_ring.c

https://github.com/Messi-Q/Vulnerabilities/blob/master/Infinite_loop_function_ring.c



