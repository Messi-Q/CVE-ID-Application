# Infinite_loop_vulnerabilites

## Vendor
Vntchain Infinite Loop 

## Vulnerability Type
Infinite Loop Bugs

## Abstract
We found a complex but common cross-function attack scenario in Vntchain smart contracts, where an attacker can undesirably reenter a function to steal money. [Vntchain](http://www.vntchain.io/?language=en) is an open-source distributed value network, which uses the Ethereum architecture for reference, and is committed to solving the current problems of high energy consumption, low efficiency and difficult to support large-scale commercial applications. The specific infinite loop scenarios can be abstracted as: (1) with the mechanism of Vntchain smart contracts, the execution of a smart contract will fall into the *fallback* function once the input is empty or error. The *fallback* function probably malicious callbacks the function causing the error. (2) another situation is that there exists a mutual invocation between functions in a single contract. While infinite loop bugs in other programming languages have been well studied, smart contracts with infinite loop bugs have not yet been issued.

## Details
### Fallback Call Ring
We present the specific steps for a specific infinite loop scenario, which caused by the *fallback* function as shown in the figure below.

<div align=center><img width="360" height="438" src="./images/fallback_call_ring.jpg"/></div>

Contract *Vulnerable* containing a transfer function *withdraw*, a check function *checkAmount*, and a *fallback* function.
* *checkAmount* is a check function, checking if the amount is enough. 
* *withdraw* declares a transfer operation, making the recipient can withdraw his asset.
* *fallback* calls the function *withdraw*, causing the reentrancy attack to the contract *Vulnerable*.
```
// Vulnerable contract
#include "vntlib.h"
...
   
// check if the amount is enough
void checkAmount(uint256 amount) {
  Require(U256_Cmp(amount, U256(0) == 1), "amount must > 0");
  address from = GetSender();
  accounts.key = from;
  uint256 balance = accounts.value.balance;
  PrintAddress("get sender:", from);
  PrintUint256T("get balance:", balance);
  Require(U256_Cmp(U256SafeSub(balance, amount), 0) != -1,
          "No enough money to bet");
}  

// withdraw asset
void withdraw(uint256 amount) {
  checkAmount(); // input error or input empty
  address addr = GetSender();
  uint256 balance = accounts.value.balance;
  if (balance >= amount) {
    TransferFromContract(addr, amount);
  }
}

$_(){ // fallback function
  count++;
  if (count < 1000){ 
    withdraw(amount);
  }
}

...
```

*Attacker* attempt to call the function *withdraw* to obtain the Vnt (the cryptocurrency of Vntchain).
```
// Attacker contract
void attack () {
  CallParams params = {Address("0xaaaa"), U256(10000), 100000}; // "0xaaaa" represents Vulnerable contract.
  withdraw(params, 100);
}
```

**Step 1** The contract *Attacker* uses the function *attack* to call the function *withdraw* to obtain the Vnt. (attack (Attacker) -> withdraw (Vulnerable))



### Function Call Ring
Contract *Vulnerable* containing a transfer function *withdraw* and a check function *checkAmount*.
* *checkAmount* is a check function, checking if the amount is enough. 
* *GetAmount* is a function for getting amount.
```
// Vulnerable contract
#include "vntlib.h"
...
   
void checkAmount(uint256 amount) {  // check if the amount is enough
  Require(U256_Cmp(amount, U256(0) == 1), "amount must > 0");
  address from = GetSender();
  accounts.key = from;
  uint256 balance = accounts.value.balance;
  PrintAddress("get sender:", from);
  PrintUint256T("get balance:", balance);
  Require(U256_Cmp(U256SafeSub(balance, amount), 0) != -1,
          "No enough money to bet");
  GetAmount(amount);
} 

UNMUTABLE
uint256 GetAmount(uint256 amount) {  // get money
  checkAmount(amount);
  return GetAmountFromAddress(GetSender()); 
}

...
```

**Step 1** In this *Vulnerable* contract, the function *checkAmount* is used to check if the amount is enough. In this function, it will call the function *GetAmount* to get amount after checking. (checkAmount -> GetAmount)

**Step 2** The function *GetAmount* attempts to get money that it will excute the operation of *checkAmount* before obtaining the amount. (GetAmount -> checkAmount)


## Conclusion
All in all, from the perspective of fallback function, the infinite loop can be probably triggered by the specific operations hidden in the fallback function. If the input data is empty or error, it will probably make the control flow enter the fallback function. From the most ordinary perspective, the mutual calls between functions will also trigger an infinite loop, causing gas and Vnt (the currency of Vntchain) to be consumed.

## Reference
https://github.com/Messi-Q/Vulnerabilities/blob/master/Infinite_loop_fallback_ring.c

https://github.com/Messi-Q/Vulnerabilities/blob/master/Infinite_loop_function_ring.c



