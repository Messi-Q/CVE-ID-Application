# Infinite-loop vulnerability

## Vendor
Vntchain Infinite Loop 

## Vulnerability Type
Infinite Loop Bugs

## Abstract
We discovered two kinds of infinite loop scenarios in Vntchain smart contracts. [Vntchain](https://github.com/vntchain) (https://github.com/vntchain) is an open-source permissionless blockchain network. In fact, infinite loops are caused by the cycled call between functions. The cycled call can be classified into two types: (1) **Fallback Call Cycle**. In the `fallback` mechanism of Vntchain, when one calls a function A of contract α, if α does not have a function A or the input parameters do not match those of function A, the `fallback` function of α will be executed. When the `fallback` function unexpectedly calls back to function A, a cycle will be formed between function A and function `fallback`. (2) **Function Call Cycle**. Another situation is that there probably exists cycled invocations between functions in a single contract, for example, function A calls function B and function B calls function A, which forms a function call cycle. While infinite loop bugs in other programming languages have been well studied, smart contracts with infinite loop bugs have not yet been issued.

## Details
### (1) Fallback Call Cycle
The following figure shows a contract with a fallback call cycle.

<div align=center><img width="395" height="330" src="./images/fallback_call_ring.png"/></div>
<div align=center>Figure 1 An example of fallback call cycle</div>

Contract `Vulnerable` contains a transfer function `withdraw`, a check function `checkAmount`, and a `fallback` function.
* `checkAmount` is a function to check if the amount is enough. 
* `withdraw` declares a transfer operation, which allows the recipient to withdraw his/her asset.
* `fallback` calls the function `withdraw`.
```
// Vulnerable contract
#include "vntlib.h"
...
   
// check if the amount is enough
void checkAmount(uint256 amount) {
  Require(U256_Cmp(amount, U256(0) == 1), "amount must > 0");
  address from = GetSender();
  accounts.key = from;
  uint256 balance = accounts.value.balance;
  PrintAddress("get sender:", from);
  PrintUint256T("get balance:", balance);
  Require(U256_Cmp(U256SafeSub(balance, amount), 0) != -1,
          "No enough money to bet");
}  

// withdraw asset
void withdraw(uint256 amount) {
  checkAmount(“checkAmount”, amount); // input does not match parameters
  address addr = GetSender();
  uint256 balance = accounts.value.balance;
  if (balance >= amount) {
    TransferFromContract(addr, amount);
  }
}

$_(){ // fallback function
  count++;
  if (count){ 
    withdraw(amount);
  }
}

...
```

Contract `Attacker` attempts to call the function `withdraw` to obtain VNT (cryptocurrency of Vntchain).
```
// Attacker contract
void attack () {
  CallParams params = {Address("0xaaaa"), U256(10000), 100000}; // "0xaaaa" represents Vulnerable contract.
  withdraw(params, 100);
}
```

The infinte loop of the fallback call cycle is formed as below:

**Step 1** The contract `Attacker` calls the function `attack` to invoke the function `withdraw` of contract `Vulnerable` for obtaining VNT. (attack (Attacker) -> withdraw (Vulnerable))

**Step 2** The contract `Vulnerable` performs the function `withdraw` to transfer money, before that it will first execute the checking operation of `checkAmount` function. (withdraw (Vulnerable) -> checkAmount (Vulnerable))

**Step 3** The `fallback` function will be triggered because the input data to function `checkAmount` does not match its paramters. However, the `fallback` function calls the `withdraw` function. (checkAmount (Vulnerable) -> fallback (Vulnerable))

**Step 4** Similar to the previous two steps, the `withdraw` function will call the `checkAmount` function, which can automatically activate the `fallback` function, resulting in the infinite loop. (fallback (Vulnerable) -> withdraw (Vulnerable) -> checkAmount (Vulnerable) -> ...)


### (2) Function Call Cycle
The following figure demonstrates a contract with a function call cycle.

<div align=center><img width=415" height="320" src="./images/function_call_ring.png"/></div>
<div align=center>Figure 2 An example of function call cycle</div>

Contract `Vulnerable` contains a check function `checkAmount` and a withdraw function `GetAmount`.
* `checkAmount` is a function to check if the amount is enough. 
* `GetAmount` is a function for getting money.
```
// Vulnerable contract
#include "vntlib.h"
...
   
void checkAmount(uint256 amount) {  // check if the amount is enough
  Require(U256_Cmp(amount, U256(0) == 1), "amount must > 0");
  address from = GetSender();
  accounts.key = from;
  uint256 balance = accounts.value.balance;
  PrintAddress("get sender:", from);
  PrintUint256T("get balance:", balance);
  Require(U256_Cmp(U256SafeSub(balance, amount), 0) != -1,
          "No enough money to bet");
  GetAmount(amount);
} 

UNMUTABLE
uint256 GetAmount(uint256 amount) {  // get money
  checkAmount(amount);
  return GetAmountFromAddress(GetSender()); 
}

...
```

The infinte loop of the function call cycle is formed as below:

**Step 1** In this `Vulnerable` contract, the function `checkAmount` is used to check if the amount is enough. The function `checkAmount` will call function `GetAmount` to get money after the checking. (checkAmount(Vulnerable) -> GetAmount(Vulnerable))

**Step 2** However, the function `GetAmount` will invoke function `checkAmount` before transfering money. (GetAmount(Vulnerable) -> checkAmount(Vulnerable))

**Step 3** Similar to the previous two steps, the function `checkAmount` will call the function `GetAmount`, which can cause itself to be called back. Therefore, the recursive call makes the execution of the contract fall into the infinite loop scenario. (checkAmount(Vulnerable) -> GetAmount(Vulnerable) -> checkAmount(Vulnerable) -> ...)

## Conclusion
The infinite loop is generally caused by the function call loop. Considering the `fallback` mechanism of smart contracts, the infinite loop can be triggered by callback operations hidden in the `fallback` function. Moreover, the infinite loop can also be triggered by cycled invocations between functions. Overall, the infinite loop can slow down the blockchain network and cause the VNT of the contract consumed in vain.

## Reference
https://github.com/Messi-Q/Vulnerabilities/blob/master/Infinite_loop_fallback_ring.c

https://github.com/Messi-Q/Vulnerabilities/blob/master/Infinite_loop_function_ring.c

https://ethereum.stackexchange.com/questions/68914/infinite-loop-in-a-view



