# State_unlocking_reentrancy

## Vendor
State-unlocking reentrancy

## Vulnerability Type
State Unlocking Reentrancy Bug

## Abstract
We found a common but uneasy-detection state-unlocking reentrancy attack scenario in Ethereum smart contracts, where an attacker can undesirably reenter a function to steal money. The attack scenario can be abstracted as: (1) given a contract *Victim* containing one transfer function *WithdrawReward* and invocation function *GetFirstWithdrawBonus*. (2) Once function *GetFirstWithdrawBonus* of contract *Victim* is called, it will get bonus by invoking the function *WithdrawReward*, the *fallback* function of *Malicious* is automatically activated. (3) In its *fallback* function, *Malicious* calls function *GetFirstWithdrawBonus*, which will undesirably call the function *WithdrawReward* to transfer money to *Malicious* again. 

## Details
We present a typical example of state unlocking reentrancy in the figure below.

<div align=center><img width="480" height="190" src="./images/state_unlocking.png"/></div>

Contract *Vulnerable* contains a transfer function *WithdrawReward* and an intermediary *GetFirstWithdrawBonus*.
* *GetFirstWithdrawBonus* is an intermediary, which is used to call the function *WithdrawReward*.
* *WithdrawReward* is a transfer function, which allows a recipient to withdraw his/her asset.
```
contract Victim {
  ...
  
  // Each recipient should only be able to claim the bonus once
  function WithdrawReward(address recipient) public {
      uint amountToWithdraw = rewardsForA[recipient];
      rewardsForA[recipient] = 0;
      if (recipient.**call.value**(amountToWithdraw)() == false) {
           throw;
      }
  }

  function GetFirstWithdrawBonus(address recipient) public {
      if (claimedBonus[recipient] == false) {  // Each recipient should only be able to claim the bonus once
           throw;
      }
      rewardsForA[recipient] += 100;
      WithdrawReward(recipient);  // At this point, the caller will be able to execute getFirstWithdrawalBonus again
      claimedBonus[recipient] = True;
  }
}
```

Contract *Malicious* containing the *attack* function and the *fallback* function.
* *attack* initates the first attack operation by calling the function *GetFirstWithdrawBonus*.
* *fallback* calls the function *GetFirstWithdrawBonus*, making the reentrancy attack to invoke *WithdrawReward* of contract *Victim*.
```
contract Malicious {
  ...
  
  function attack(){
    vul.GetFirstWithdrawBonus(_owner);
  }

  function () payable{ // fallback function
    count++;
    if(count < 10){
      vul.GetFirstWithdrawBonus(_owner);
    }
  }
}
```

**Step 1** The contract ** uses the function *attack* to call the function *GetFirstWithdrawBonus*, aiming at obatining the bonus (Ether or money). (attack (Malicious) -> GetFirstWithdrawBonus (Victim))

**Step 2** Due to the **Step 1**, the function *GetFirstWithdrawBonus* involves the transfer function *WithdrawReward*, which will be called to tansfer money to contract *Malicious*. (GetFirstWithdrawBonus (Victim) -> WithdrawReward (Victim))

**Step 3** Further, after **Step 2**, it will automatically trigger the *fallback* function of *Malicious*. (WithdrawReward (Victim) -> fallback (Malicious))

**Step 4** The *fallback* function of contract *Malicious* maliciously invokes the function *GetFirstWithdrawBonus* to attempt to obtain the Ether again. (fallback (Malicious) -> GetFirstWithdrawBonus (Victim))

**Step 5** Similarly, The function *GetFirstWithdrawBonus* reenter the function *WithdrawReward* to transfer money to contract *Malicious*, causing the recursive calls. By exploiting the reentrant call, the *Malicious* can access the contract *Victim* to steal Ether until all its Ether is exhausted. (GetFirstWithdrawBonus (Victim) -> WithdrawReward (Victim) -> fallback (AttaMaliciouscker) -> ...)

## Conclusion
All in all, this reentrancy attack utilizes the shared interval states (i.e., intermediary function) to steal the Ether from the victim contract. Also, this is a trick for exploiting the control dependencies between functions, causing the reentrancy attack. Even though *getFirstWithdrawalBonus* doesn't directly execute a transfer operation, the *withdrawReward* called by *getFirstWithdrawalBonus* is enough to make it vulnerable to reentrancy. 

## Reference
https://github.com/Messi-Q/Vulnerabilities/blob/master/Reentrancy_state_unlocking.sol

https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21

https://consensys.github.io/smart-contract-best-practices/known_attacks/



