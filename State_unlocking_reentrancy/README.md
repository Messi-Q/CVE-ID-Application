# State_unlocking_reentrancy

## Vendor
State-unlocking reentrancy

## Vulnerability Type
State Unlocking Reentrancy Bug

## Abstract
We found a state-unlocking reentrancy attack scenario based on shared interval states in Ethereum smart contracts, where an attacker can undesirably re-enter a function to steal money. This attack scenario can be abstracted as: (1) given a contract `Victim` containing a transfer function `WithdrawReward` and an invocation function `GetFirstWithdrawBonus`. (2) Once the function `GetFirstWithdrawBonus` of contract `Victim` is called, it will then invoke the function `WithdrawReward` to withdraw Ether to a contract `Malicious`, the `fallback` function of `Malicious` is automatically activated. (3) In its `fallback` function, `Malicious` calls function `GetFirstWithdrawBonus`, which will undesirably transfer money to `Malicious` again. 

## Details
We present a typical example of state unlocking reentrancy in the figure below.

<div align=center><img width="490" height="200" src="./images/state_unlocking.png"/></div>
<div align=center>Figure 1 An example of state unlocking reentrancy</div>

Contract `Vulnerable` contains a transfer function `WithdrawReward` and a bonus function `GetFirstWithdrawBonus`.
* `GetFirstWithdrawBonus` is a bonus function, which gives the first bonus to a user who applies for the first time.
* `WithdrawReward` is a transfer function, which allows a recipient to withdraw his/her asset.
```
contract Victim {
  ...
  
  // Each recipient should only be able to claim the bonus once
  function WithdrawReward(address recipient) public {
      uint amountToWithdraw = rewardsForA[recipient];
      rewardsForA[recipient] = 0;
      if (recipient.call.value(amountToWithdraw)() == false) {
           throw;
      }
  }

  function GetFirstWithdrawBonus(address recipient) public {
      if (claimedBonus[recipient] == false) {  // Each recipient should only be able to claim the bonus once
           throw;
      }
      rewardsForA[recipient] += 100;
      WithdrawReward(recipient);  // At this point, the caller will be able to execute getFirstWithdrawalBonus again
      claimedBonus[recipient] = True;
  }
}
```

Contract `Malicious` contains an `attack` function and a `fallback` function.
* `attack` initates the attack to get first bonus by calling the function `GetFirstWithdrawBonus`.
* `fallback` calls the function `GetFirstWithdrawBonus` to invoke the function `WithdrawReward` of contract `Victim`.
```
contract Malicious {
  ...
  
  function attack(){
    vul.GetFirstWithdrawBonus(_owner);
  }

  function () payable{ // fallback function
    count++;
    if(count < 10){
      vul.GetFirstWithdrawBonus(_owner);
    }
  }
}
```

The attack process is as follows:

**Step 1** The contract `Malicious` uses the function `attack` by calling the function `GetFirstWithdrawBonus` of contract `Victim`, aiming to obtain the bonus (Ether). (attack (Malicious) -> GetFirstWithdrawBonus (Victim))

**Step 2** The function `GetFirstWithdrawBonus` executes the function `WithdrawReward` of contract `Victim` to send money to contract `Malicious` by the transfer operation `if (recipient.call.value(amountToWithdraw)() == false)` (line 6 in Figure 1 left). (GetFirstWithdrawBonus (Victim) -> WithdrawReward (Victim))

**Step 3** The contract `Malicious` receives the transferred money. This will automatically trigger the `fallback` function of `Malicious`. (WithdrawReward (Victim) -> fallback (Malicious))

**Step 4** The `fallback` function of `Malicious` maliciously invokes the function `GetFirstWithdrawBonus` to attempt to obtain Ether again. (fallback (Malicious) -> GetFirstWithdrawBonus (Victim))

**Step 5** Similarly, the function `GetFirstWithdrawBonus` of contract `Victim` re-enters the function `WithdrawReward` to transfer money to contract `Malicious`, causing recursive calls. In total, function `GetFirstWithdrawBonus` is called 9 times (if(count < 10) (line 11 in Figure 1 right)), while the function `WithdrawReward` will be called 9 times correspondingly. Therefore, by exploiting the reentrant call, the `Malicious` can access the contract `Victim` to get more bonus than expected. (GetFirstWithdrawBonus (Victim) -> WithdrawReward (Victim) -> fallback (AttaMaliciouscker) -> ...)

**Analysis** `rewardsForA[recipient]` is the critical value as it records the amount of Ether that the call's recipient has in the contract. `rewardsForA[recipient]` is set to zero before the transfer operation `if (recipient.call.value(amountToWithdraw)() == false)`; (line 6 in Figure 1 left) of function `WithdrawReward` is executed. This transfer operation will trigger the `fallback` function of contract `Malicious`. However, `rewardsForA[recipient]` in function `GetFirstWithdrawBonus` is added to 100 before calling the function `WithdrawReward`, thus making the contract `Victm` believe that the attacker still has enough Ether in the contract. Then, the `fallback` function of contract `Malicious` calls the function `GetFirstWithdrawBonus` of `Victim`, leading to call the function `WithdrawReward` of `GetFirstWithdrawBonus` recurrently until the count reaches 10. `if (count < 10) { vul.GetFirstWithdrawBonus(_owner); }` (line 11 in Figure 1 right).

For example, an attacker wants to get the first bonus of 10 Ether from contract `Victim` by calling the function `GetFirstWithdrawBonus` of `Victim`. Then, the attacker utilizes the fallback function to call the function `GetFirstWithdrawBonus` of `Victim` 9 times. In total, the attacker will get a bonus of 90 Ether, which is much more than expected.

## Conclusion
Overall, we would like to highlight that this reentrancy attack utilizes shared interval states to steal Ether from the victim contract. Also, this is a trick of exploiting the control dependencies between functions, causing the reentrancy attack. Even though `getFirstWithdrawalBonus` does not directly execute a transfer operation, the `withdrawReward` called by `getFirstWithdrawalBonus` is enough to make it vulnerable to reentrancy. 

## Reference
https://github.com/Messi-Q/Vulnerabilities/blob/master/Reentrancy_state_unlocking.sol

https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21

https://consensys.github.io/smart-contract-best-practices/known_attacks/



