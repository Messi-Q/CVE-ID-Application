# Infinite loop vulnerabilites

## Vendor
Vntchain Infinite Loop 

## Vulnerability Type
Infinite Loop Bugs

## Abstract
We found two kinds of infinite loop scenarios in Vntchain smart contracts. [Vntchain](http://www.vntchain.io/?language=en) is an open-source distributed value network, which is committed to solving current problems of high energy consumption, low efficiency and difficult to support large-scale commercial applications. In fact, infinite loops are caused by the ring call between functions. The specific ring call can be abstracted as: (1) **Fallback Call Ring**, with the `fallback` mechanism of Vntchain smart contracts, the function A execution of a smart contract will fall into the `fallback` function when the input is empty or error.  The `fallback` function unexpectedly callbacks the function A, which will form a fallback call ring. (2) **Function Call Ring**, another situation is that there probably exists a mutual invocation between functions in a single contract, namely function A calls function B and function B calls function A, which forms a function call ring. While infinite loop bugs in other programming languages have been well studied, smart contracts with infinite loop bugs have not yet been issued.

## Details
### (1) Fallback Call Ring
We present a typical example of fallback call ring as shown in the figure below.

<div align=center><img width="395" height="330" src="./images/fallback_call_ring.png"/></div>
<div align=center>Figure 1 An example of fallback call ring</div>

Contract `Vulnerable` contains a transfer function `withdraw`, a check function `checkAmount`, and a `fallback` function.
* `checkAmount` is a function to check if the amount is enough. 
* `withdraw` declares a transfer operation, which allows the recipient can withdraw his/her asset.
* `fallback` calls the function `withdraw`, which makes the execution of contact callback to the `withdraw`.
```
// Vulnerable contract
#include "vntlib.h"
...
   
// check if the amount is enough
void checkAmount(uint256 amount) {
  Require(U256_Cmp(amount, U256(0) == 1), "amount must > 0");
  address from = GetSender();
  accounts.key = from;
  uint256 balance = accounts.value.balance;
  PrintAddress("get sender:", from);
  PrintUint256T("get balance:", balance);
  Require(U256_Cmp(U256SafeSub(balance, amount), 0) != -1,
          "No enough money to bet");
}  

// withdraw asset
void withdraw(uint256 amount) {
  checkAmount(“checkAmount”, amount); // input error or input empty
  address addr = GetSender();
  uint256 balance = accounts.value.balance;
  if (balance >= amount) {
    TransferFromContract(addr, amount);
  }
}

$_(){ // fallback function
  count++;
  if (count){ 
    withdraw(amount);
  }
}

...
```

Contract `Attacker` attempts to call the function `withdraw` to obtain Vnt (cryptocurrency of Vntchain).
```
// Attacker contract
void attack () {
  CallParams params = {Address("0xaaaa"), U256(10000), 100000}; // "0xaaaa" represents Vulnerable contract.
  withdraw(params, 100);
}
```

The infinite loop of fallback call ring is as follows:

**Step 1** The contract `Attacker` calls the function `attack` to call the function `withdraw` of contract `Vulnerable` to obtain Vnt. (attack (Attacker) -> withdraw (Vulnerable))

**Step 2** The contract `Vulnerable` performs the function `withdraw` to get money, which will first execute the checking operation of `checkAmount` function. (withdraw (Vulnerable) -> checkAmount (Vulnerable))

**Step 3** The `fallback` function will be triggered since the input data into `checkAmount` is error. Then, the `fallback` function calls the `withdraw` function again. (checkAmount (Vulnerable) -> fallback (Vulnerable))

**Step 4** Similar to the previous two steps, the `withdraw` function will call the `checkAmount` function, which can automatically activate the `fallback` function, resulting in the infinite loop. (fallback (Vulnerable) -> withdraw (Vulnerable) -> checkAmount (Vulnerable) -> ...)


### (2) Function Call Ring
We present a typical example of function call ring as shown in the figure below.

<div align=center><img width=415" height="320" src="./images/function_call_ring.png"/></div>
<div align=center>Figure 2 An example of function call ring</div>

Contract `Vulnerable` contains a check function `checkAmount` and a withdraw function `GetAmount`.
* `checkAmount` is a function to check if the amount is enough. 
* `GetAmount` is a function for getting amount.
```
// Vulnerable contract
#include "vntlib.h"
...
   
void checkAmount(uint256 amount) {  // check if the amount is enough
  Require(U256_Cmp(amount, U256(0) == 1), "amount must > 0");
  address from = GetSender();
  accounts.key = from;
  uint256 balance = accounts.value.balance;
  PrintAddress("get sender:", from);
  PrintUint256T("get balance:", balance);
  Require(U256_Cmp(U256SafeSub(balance, amount), 0) != -1,
          "No enough money to bet");
  GetAmount(amount);
} 

UNMUTABLE
uint256 GetAmount(uint256 amount) {  // get money
  checkAmount(amount);
  return GetAmountFromAddress(GetSender()); 
}

...
```

The infinite loop of function call ring is as follows:

**Step 1** In this `Vulnerable` contract, the function `checkAmount` is used to check if the amount is enough. In this function, it will call the function `GetAmount` to get the amount after checking. (checkAmount(Vulnerable) -> GetAmount(Vulnerable))

**Step 2** The function `GetAmount` attempts to get money that it will execute `checkAmount` before obtaining the amount. (GetAmount(Vulnerable) -> checkAmount(Vulnerable))

**Step 3** Similar to the previous two steps, the function `checkAmount` will call the function `GetAmount`, which can cause itself to be called back. Therefore, the recursive call makes the execution of the contract fall into the infinite loop scenario. (checkAmount(Vulnerable) -> GetAmount(Vulnerable) -> checkAmount(Vulnerable) -> ...)

## Conclusion
Overall, we would like to highlight that the infinite loop is generally caused by the functions call ring. Considering the perspective of the `fallback` function, the infinite loop can be triggered by callback operations hidden in the `fallback` function. If the input data is empty or error, it will probably make the control flow re-enter the `fallback` function, leading to the infinite loop. Without considering the `fallback` function, the ring call between functions will also trigger the infinite loop, causing gas and Vnt to be consumed.

## Reference
https://github.com/Messi-Q/Vulnerabilities/blob/master/Infinite_loop_fallback_ring.c

https://github.com/Messi-Q/Vulnerabilities/blob/master/Infinite_loop_function_ring.c

https://ethereum.stackexchange.com/questions/68914/infinite-loop-in-a-view



