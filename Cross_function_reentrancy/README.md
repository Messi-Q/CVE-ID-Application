# Cross_function_reentrancy

## Vendor
Cross-function Reentrancy

## Vulnerability Type
Cross Function Reentrancy Bug

## Abstract
We found a complex but common cross-function attack scenario in Ethereum smart contracts, where an attacker can undesirably reenter a function to steal money. The attack scenario can be abstracted as: (1) given a contract *Vulnerable* containing two transfer functions *getBonus* and *withdraw*, which can transfer Ether (cryptocurrency in Ethreum) to another contract. (2) Once function *getBonus* of contract *Vulnerable* is called to send some Ether to a contract *Attacker*, the *fallback* function of *Attacker* is automatically invoked. (3) In its *fallback* function, *Attacker* calls function *withdraw*, which will undesirably transfer money to *Attacker* again. While reentrancy exploiting one single function has been well studied, reentrancy vulnerability using cross-function has not yet been issued.

## Details
We present a typical example of cross-function reentrancy in the figure below.

<div align=center><img width="520" height="240" src="./images/cross-function.png"/></div>

Contract *Vulnerable* contains two transfer functions *withdrawAll* and *withdrawPortion*, both the two functions can send Ether to another contract address.
* *withdrawAll* declares a transfer operation, which allows a recipient to claim his/her bonus.
* *withdrawPortion* declares another transfer operation, which allows a recipient to withdraw his/her asset.
```
contract Vulnerable{
  ...
  
  // withdraw all the money
  function withdrawAll(address to) external {
      uint256 amount = balances[msg.sender];
      if (balances[msg.sender] > 0) {
        require(msg.sender.call.value(amount)());
        totalbalance -= _amount;
    	  balances[msg.sender] = 0;
      }
  }
  
  // withdraw part the money
  function withdrawPortion(uint _amount) external {   
     if (balances[msg.sender] >= amount) {
        require(msg.sender.call.value(amount)());
        totalbalance -= _amount;
        userBalances[msg.sender] -= amount;
     }
  }
}
```

Contract *Attacker* contains a *attack* function and a *fallback* function.
* *attack* initates the first attack to withdraw all the money by calling the function *withdrawAll*.
* *fallback* calls the function *withdrawPortion* to obtain money from contract *Vulnerable*.
```
contract Attacker{
  ...
  
  function attack(){
    vul.withdrawAll(_owner);
  }

  function () payable{ // fallback function
     count++;
     if(count < 10){
       vul.withdrawPortion(1 ether);
     }
  }
}
```


**Step 1** The contract *Attacker* uses the function *attack* to call the function *getBonus* to obtain the bonus (Ether or money), aiming to initiate the attack. (attack (Attacker) -> getBonus (Vulnerable))

**Step 2** Due to the **Step 1**, the function *getBonus* involves the transfer operation (i.e., recipient.call.value(amountToWithdraw)() == false), which will automatically trigger the fallback function of *Attacker*. (withdraw (Vulnerable) -> fallback (Attacker))

**Step 3** The *fallback* function of contract *Attacker* maliciously invokes the function *withdraw* to withdraw its Ether. (fallback (Attacker) -> withdraw (Vulnerable))

**Step 4** However, the function *withdraw* also trigger the fallback function due to "msg.sender.call.value(_amount)()", which involuntarily triggers the *fallback* function of *Attacker* again. (withdraw (Vulnerable) -> fallback (Attacker))

**Step 5** Similarly, The *fallback* function reenter the contract *Vulerable* by calling the function *withdraw*, causing the recursive calls. By exploiting the reentrant call, the *Attacker* can access to the contract *Vulnerable* to steal Ether until all its Ether is exhausted. (fallback (Attacker) -> withdraw (Vulnerable) -> ...)

## Conclusion
Overall, we would like to highlight that this reentrancy situation is common in many Ethereum smart contracts. Attacker makes use of two transfer functions of the vulnerable contract and the fallback mechanism to reenter the vulnerable contract for stealing money. Since reentrancy can occur across multiple functions and current reentrancy detection tools are single function-based, solutions aiming at detecting cross-function reentrancy is urgently required.

## Reference
https://consensys.github.io/smart-contract-best-practices/known_attacks/

https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21

https://github.com/Messi-Q/Vulnerabilities/blob/master/Reentrancy_cross_function.sol

