# Cross_function_reentrancy

## Vendor
Cross-function Reentrancy

## Vulnerability Type
Cross Function Reentrancy Bug

## Abstract
We found a complex but common cross-function attack scenario in Ethereum smart contracts, where an attacker can undesirably re-enter a function to steal money. The attack scenario can be abstracted as: (1) given a contract `Vulnerable` containing two transfer functions `withdrawPortion` and `withdrawAll`, which can transfer Ether (the cryptocurrency of Ethreum) to another contract. (2) Once the function `withdrawAll` of contract `Vulnerable` is called to withdraw Ether to a contract `Attacker`, the `fallback` function of `Attacker` is automatically invoked. (3) In its `fallback` function, `Attacker` calls function `withdrawPortion`, which will undesirably transfer money to `Attacker` again. While reentrancy exploiting one single function has been well studied, the cross-function reentrancy has not yet been issued.

## Details
We present a typical example of cross-function reentrancy in the figure below.

<div align=center><img width="520" height="240" src="./images/cross-function.png"/></div>

Contract `Vulnerable` contains two transfer functions `withdrawAll` and `withdrawPortion`, both of the two functions can send Ether to another contract address.
* `withdrawAll` declares a transfer operation, which allows a recipient to withdraw all his/her asset.
* `withdrawPortion` declares another transfer operation, which allows a recipient to withdraw part of his/her asset.
```
contract Vulnerable{
  ...
  
  // withdraw all the money
  function withdrawAll(address to) external {
      uint256 amount = balances[msg.sender];
      if (balances[msg.sender] > 0) {
        require(msg.sender.call.value(amount)());
    	  balances[msg.sender] = 0;
      }
  }
  
  // withdraw part of the money
  function withdrawPortion(uint _amount) external {   
     if (balances[msg.sender] >= amount) {
        require(msg.sender.call.value(amount)());
        balances[msg.sender] -= amount;
     }
  }
}
```

Contract `Attacker` contains an `attack` function and a `fallback` function.
* `attack` initiates the attack to withdraw money by calling the function `withdrawAll`.
* `fallback` calls the function `withdrawPortion` to steal money from contract `Vulnerable`.
```
contract Attacker{
  ...
  
  function attack(){
    vul.withdrawAll(_owner);
  }

  function () payable{ // fallback function
     count++;
     if(count < 10){
       vul.withdrawPortion(1 ether);
     }
  }
}
```

The attack process is as follows:

**Step 1** The contract `Attacker` uses the function `attack` to call the function `withdrawAll` of contract `Vulnerable`,  aiming to withdraw his/her asset (Ether). (attack (Attacker) -> withdrawAll (Vulnerable))

**Step 2** The function `withdrawAll` executes the transfer operation `"require(msg.sender.call.value(amount)());"` to send money to contract `Attacker`. This will automatically trigger the `fallback` function of `Attacker`. (withdrawAll (Vulnerable) -> fallback (Attacker))

**Step 3** The `fallback` function of `Attacker` maliciously invokes the function `withdrawPortion` of `Vulnerable` to withdraw Ether for the second time. (fallback (Attacker) -> withdraw (Vulnerable))

**Step 4** The function `withdrawPortion` executes the transfer operation `"require(msg.sender.call.value(amount)());"` to send money to contract `Attacker`. This will automatically trigger the `fallback` function of `Attacker` again. (withdraw (Vulnerable) -> fallback (Attacker))

**Step 5** Similarly, the `fallback` function re-enters the contract `Vulerable` the third time by calling the function `withdrawPortion`, causing the recursive calls. In total, function `withdrawPortion` is called 9 times (`if(count < 10)`). By exploiting the reentrant call, the `Attacker` can access the contract `Vulnerable` to steal Ether . (fallback (Attacker) -> withdraw (Vulnerable) -> ...)

## Conclusion
Overall, we would like to highlight that this reentrancy situation is common in many Ethereum smart contracts. Attackers can make use of two transfer functions of the vulnerable contract and the `fallback` mechanism to re-enter the vulnerable contract for stealing money. Since reentrancy can occur across multiple functions and current reentrancy detection tools are single function-based, solutions aiming at detecting cross-function reentrancy is urgently required.

## Reference
https://consensys.github.io/smart-contract-best-practices/known_attacks/

https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21

https://github.com/Messi-Q/Vulnerabilities/blob/master/Reentrancy_cross_function.sol

